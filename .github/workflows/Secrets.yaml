name: Secrets

on:
  workflow_dispatch:
  push:
    branches:
      - main

defaults:
  run:
    shell: PowerShell

jobs:
  update:
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v2

      - name: Read Settings
        run: |
          # This servers as an example of Read Settings, leaving a secret mapping for the ReadSecrets
          $settings = @{ "TestSecretSecretName" = "NYTEST" } | ConvertTo-Json -compress
          Add-Content -Path $env:GITHUB_ENV -Value "settings=$settings"

      - name: Get Secret Specification
        id: GetSecretsSpec
        env:
          Secrets: ghTokenWorkflow,TestSecret,SomeTest,OtherSecret
        run: |
          # Create a number of outputs named S0, S1, S2, etc. for each secret, holding the actual GitHub Secret name to look for
          # Create a json format string for the secrets, to be used in the next step
          $settings = $env:settings | ConvertFrom-Json
          $formatArr = @()
          $cnt = 0
          foreach($secret in $env:Secrets.Split(',')) {
            $secretName = $secret
            if ($settings.PSObject.Properties.Name -eq "$($secret)SecretName") {
              $secretName = $settings."$($secret)SecretName"
            }
            $formatArr += @("""$Secret"":{$cnt}")
            Add-Content $ENV:GITHUB_OUTPUT "S$cnt=$secretName"
            Write-Host "S$cnt=$secretName"
            $cnt++
          }
          Write-Host "formatStr={{$($formatArr -join ',')}}"
          Add-Content $ENV:GITHUB_OUTPUT "formatStr={{$($formatArr -join ',')}}"
          if ($cnt -gt 16) {
            throw "Too many secrets"
          }

      - name: ReadSecretFromGitHub
        id: ReadSecretsFromGitHub
        env:
          SECRETS_JSON: ${{ format(steps.GetSecretsSpec.outputs.formatStr,toJSON(secrets[steps.GetSecretsSpec.outputs.S0]),toJSON(secrets[steps.GetSecretsSpec.outputs.S1]),toJSON(secrets[steps.GetSecretsSpec.outputs.S2]),toJSON(secrets[steps.GetSecretsSpec.outputs.S3]),toJSON(secrets[steps.GetSecretsSpec.outputs.S4]),toJSON(secrets[steps.GetSecretsSpec.outputs.S5]),toJSON(secrets[steps.GetSecretsSpec.outputs.S6]),toJSON(secrets[steps.GetSecretsSpec.outputs.S7]),toJSON(secrets[steps.GetSecretsSpec.outputs.S8]),toJSON(secrets[steps.GetSecretsSpec.outputs.S9]),toJSON(secrets[steps.GetSecretsSpec.outputs.S10]),toJSON(secrets[steps.GetSecretsSpec.outputs.S11]),toJSON(secrets[steps.GetSecretsSpec.outputs.S12]),toJSON(secrets[steps.GetSecretsSpec.outputs.S13]),toJSON(secrets[steps.GetSecretsSpec.outputs.S14]),toJSON(secrets[steps.GetSecretsSpec.outputs.S15])) }}
        run: |
          Add-Content -encoding UTF8 -Path $env:GITHUB_OUTPUT -Value "Secrets=$ENV:SECRETS_JSON"
          # Test: Display the secrets lengths
          $mySecrets = $ENV:SECRETS_JSON | ConvertFrom-Json
          Write-Host $mySecrets.GhTokenWorkflow.Length
          Write-Host $mySecrets.TestSecret.Length
          Write-Host $mySecrets.SomeTest.Length
          Write-Host $mySecrets.OtherSecret.Length
          # String literals with special characters are not support in yaml files
          # This string is base 64 encoded version of: PæreSü©Ʃɸ
          $s1 = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('UMOmcmVTw7zCqcapybg='))
          $s2 = 'PæreSü©Ʃɸ'
          if ($s1 -eq $s2) {
            Write-Host "Inline PowerShell string is utf8"
          }
          if ($mySecrets.SomeTest -eq $s1) {
            Write-Host "Secret read successfully"
          }

      - name: ReadSecret
        id: ReadSecrets
        run: |
          # Call into action to retrieve the missing secrets from Azure Key Vault if avaialable
          # Ensure encoding etc. is done correctly
